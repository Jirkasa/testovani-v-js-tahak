<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0 user-scalable=yes maximum-scale=2.2 minimum-scale=1.0">
    <title>Testování v JS - Tahák</title>

    <meta name="author" content="Jiří Satora">
    <meta name="description" content="Tahák pro testování v JavaScriptu.">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oxanium:wght@700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" rel="stylesheet">

    <link rel="icon" type="image/svg+xml" href="./assets/img/favicon.svg"/>

    <link rel="stylesheet" href="./assets/css/style.css">

    <script src="./assets/js/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>
<body>
    <div class="page">
        <header class="intro-section">
            <div class="intro-section__content">
                <h1 class="heading-primary u-mb-6">Testování v JS</h1>
                <hr class="horizontal-rule u-mb-6"/>
                <div class="heading-primary-sub u-mb-6">Tahák</div>
                <hr class="horizontal-rule u-mb-6"/>
                <div class="intro-section__text u-mb-8">
                    <p>Tato stránka je tahákem pro testování v JavaScriptu s použitím nástroje jménem Vitest. Jedná se o testovací framework, který je hodně podobný populárnímu frameworku jménem Jest.</p>
                </div>
                <div class="intro-section__icon">
                    <svg>
                        <use xlink:href="./assets/img/icon-sprite.svg#icon-triangle"></use>
                    </svg>
                </div>
            </div>
        </header>
        <section id="proc-psat-testy" class="section">
            <div class="section__content">
                <h2 class="heading-secondary u-center-text u-mb-8">Proč psát testy</h2>
                <div class="grid">
                    <div class="grid__col-1-of-3">
                        <div class="rect-icon u-mb-4">
                            <svg>
                                <use xlink:href="./assets/img/icon-sprite.svg#icon-point-up"></use>
                            </svg>
                        </div>
                        <div class="text-box">
                            <p class="paragraph paragraph--white">Vyhneme se nekonečnému manuálnímu testování.</p>
                        </div>
                    </div>
                    <div class="grid__col-1-of-3">
                        <div class="rect-icon u-mb-4">
                            <svg>
                                <use xlink:href="./assets/img/icon-sprite.svg#icon-file-text2"></use>
                            </svg>
                        </div>
                        <div class="text-box">
                            <p class="paragraph paragraph--white">Po každé změně se naše testy mohou automaticky spustit, a zkontrolovat, jestli se něco nerozbilo</p>
                        </div>
                    </div>
                    <div class="grid__col-1-of-3">
                        <div class="rect-icon u-mb-4">
                            <svg>
                                <use xlink:href="./assets/img/icon-sprite.svg#icon-terminal"></use>
                            </svg>
                        </div>
                        <div class="text-box">
                            <p class="paragraph paragraph--white">Psaní testů nás nutí psát čistší kód, protože se pro něj potom lépe vytvářejí testy.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        <section id="typy-testu" class="section section--alt">
            <div class="section__content">
                <h2 class="heading-secondary u-center-text u-mb-6">Typy testů</h2>
                <div class="intro-text u-mb-6">
                    <p class="paragraph paragraph--dark">Existují různé typy testů. Je jich více, ale ty nejznámější jsou pravděpodobně Unit testy, Integration testy a End-to-end testy.</p>
                </div>
                <div class="grid u-center-text">
                    <div class="grid__col-1-of-3">
                        <h3 class="heading-tertiary u-mb-4">Unit testy</h3>
                        <p class="paragraph paragraph--dark">Testování individuálních stavebních bloků aplikace. Každý stavební blok (unit) je testován zvlášť. Stavebním blokem je většinou funkce nebo třída, která nepoužívá jiné stavební bloky. Pokud dělám unit test, tak chceme testovat specifický stavební blok, jiné ne.</p>
                    </div>
                    <div class="grid__col-1-of-3">
                        <h3 class="heading-tertiary u-mb-4">Integration testy</h3>
                        <p class="paragraph paragraph--dark">Testování kombinace stavebních bloků (unit). Testuje se jestli určité stavební bloky fungují dohromady. I když všechny stavební bloky fungují samostatně, tak se může stát, že pokud budou pracovat dohromady, tak dojde k selhání.</p>
                    </div>
                    <div class="grid__col-1-of-3">
                        <h3 class="heading-tertiary u-mb-4">E2E testy</h3>
                        <p class="paragraph paragraph--dark">End-to-end nejsou nijak spjaty s Unit a Integration testy. Jejich úkolem je testovat kompletní funkcionalitu aplikace. Protože uživatelé používají celou aplikaci, ne jen její část.</p>
                    </div>
                </div>
            </div>
        </section>
        <section id="co-testovat" class="section">
            <div class="section__content">
                <h2 class="heading-secondary u-center-text u-mb-8">Co (ne)testovat</h2>
                <div class="grid">
                    <div class="grid__col-1-of-3">
                        <div class="rect-icon u-mb-4">
                            <svg>
                                <use xlink:href="./assets/img/icon-sprite.svg#icon-embed2"></use>
                            </svg>
                        </div>
                        <div class="text-box">
                            <p class="paragraph paragraph--white">Vždy bychom měli testovat jen vlastní kód. Pokud používáme nějaké knihovny třetích stran, tak ty netestujeme.</p>
                        </div>
                    </div>
                    <div class="grid__col-1-of-3">
                        <div class="rect-icon u-mb-4">
                            <svg>
                                <use xlink:href="./assets/img/icon-sprite.svg#icon-target"></use>
                            </svg>
                        </div>
                        <div class="text-box">
                            <p class="paragraph paragraph--white">Měli bychom testovat vždy jen jednu věc. Neměli bychom v jednom testu testovat několik věcí najednou.</p>
                        </div>
                    </div>
                    <div class="grid__col-1-of-3">
                        <div class="rect-icon rect-icon--red u-mb-4">
                            <svg>
                                <use xlink:href="./assets/img/icon-sprite.svg#icon-ungroup"></use>
                            </svg>
                        </div>
                        <div class="text-box text-box--red">
                            <p class="paragraph paragraph--white">Pokud testujeme frontend aplikaci, tak bychom zároveň neměli testovat i backend. Backend můžeme testovat zvlášť.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        <section id="co-je-k-testovani-potreba" class="section section--alt">
            <div class="section__content">
                <h2 class="heading-secondary u-center-text u-mb-6">Co je k testování potřeba</h2>
                <div class="intro-text u-mb-6">
                    <p class="paragraph paragraph--dark">Pro testování našeho kódu potřebujeme tři základní věci. Potřebujeme Test Runner, Assertion Library a samozřejmě kód aplikace, kterou chceme testovat.</p>
                </div>
                <div class="grid u-center-text">
                    <div class="grid__col-1-of-3">
                        <h3 class="heading-tertiary u-mb-4">Aplikační kód</h3>
                        <p class="paragraph paragraph--dark">K vytváření testů a jejich spouštění potřebujeme samozřejmě kód naší aplikace. Testování může být (a většinou i je) v naší aplikaci integrováno. Pokud jsme například naši aplikaci vytvořili pomocí nějakého nástroje postaveného třeba na Webpacku (např. Create React App), tak pro nás může být testování připraveno.</p>
                    </div>
                    <div class="grid__col-1-of-3">
                        <h3 class="heading-tertiary u-mb-4">Test Runner</h3>
                        <p class="paragraph paragraph--dark">Test Runner představuje nástroj pro spouštění našich testů. Automaticky detekuje testovací kód, spouští jej a zobrazuje pro něj výsledky. Populárními test runnery jsou například Jest, Vitest nebo Karma.</p>
                    </div>
                    <div class="grid__col-1-of-3">
                        <h3 class="heading-tertiary u-mb-4">Assertion Library</h3>
                        <p class="paragraph paragraph--dark">Kromě test runneru potřebujeme k testování také Assertion Library. Tento nástroj slouží k definování výsledků, které po proběhnutím testu očekáváme. Assertion Library zjišťuje jestli se naše očekávání splní nebo ne. Populární Assertion knihovny jsou například Jest, Vitest nebo Chai.</p>
                    </div>
                </div>
            </div>
        </section>
        <section id="aaa-vzor" class="section">
            <div class="section__content">
                <h2 class="heading-secondary u-center-text u-mb-6">AAA vzor</h2>
                <div class="intro-text u-mb-6">
                    <p class="paragraph">AAA vzor se stal v testování skoro standardem. Rozděluje tvorbu testů na tři fáze: Arrange (připrav), Act (proveď) a Assert (vyhodnoť).</p>
                </div>
                <div class="grid u-center-text u-mb-6">
                    <div class="grid__col-1-of-3">
                        <h3 class="heading-tertiary u-mb-4">Arrange</h3>
                        <p class="paragraph">V této fázi si připravíme testovací prostředí a nadefinujeme hodnoty.</p>
                    </div>
                    <div class="grid__col-1-of-3">
                        <h3 class="heading-tertiary u-mb-4">Act</h3>
                        <p class="paragraph">V této fázi provedeme testování. Spustíme nějaký kód, který chceme otestovat.</p>
                    </div>
                    <div class="grid__col-1-of-3">
                        <h3 class="heading-tertiary u-mb-4">Assert</h3>
                        <p class="paragraph">V této fázi vyhodnotíme výsledek testu. Porovnáme výslednou hodnotu s očekávanou hodnotou.</p>
                    </div>
                </div>
                <pre class="code-box"><code>it("should summarize all numbers in an array", () => {
    // arrange
    const numbers = [1, 2, 3];
    const expectedResult = 6;

    // act
    const result = add(number);

    // assert
    expect(result).toBe(expectedResult);
});</code></pre>
            </div>
        </section>
        <section id="spousteni-testu" class="section section--alt">
            <div class="section__content">
                <h2 class="heading-secondary u-center-text u-mb-6">Spouštění testů</h2>
                <div class="intro-text u-mb-6">
                    <p class="paragraph paragraph--dark">Ke spuštění testů můžeme použít příkaz 'vitest', který si můžeme nastavit jako test script v našem package.json souboru. Po jeho spuštění Vitest automaticky prohledá v našem projektu soubory s koncovkou .test.js nebo .spec.js a spustí je.</p>
                </div>
                <p class="big-text u-center-text"><span class="u-highlight-text">vitest</span> | <span class="u-highlight-text">vitest watch</span> - spouští testy ve watch módu</p>
                <p class="big-text u-center-text u-mb-6"><span class="u-highlight-text">vitest run</span> - spouští testy jen jednou</p>
                <a href="https://vitest.dev/guide/cli.html#options" target="_blank" class="link-with-icons">
                    <div class="link-with-icons__icon">
                        <svg>
                            <use xlink:href="./assets/img/icon-sprite.svg#icon-arrow-right2"></use>
                        </svg>
                    </div>
                    <span>zobrazit možnosti</span>
                    <div class="link-with-icons__icon">
                        <svg>
                            <use xlink:href="./assets/img/icon-sprite.svg#icon-arrow-left2"></use>
                        </svg>
                    </div>
                </a>
            </div>
        </section>
        <section id="vytvoreni-testu" class="section">
            <div class="section__content">
                <h2 class="heading-secondary u-center-text u-mb-6">Vytvoření testu</h2>
                <div class="intro-text u-mb-6">
                    <p class="paragraph">Vitest obsahuje funkce it a test, které nám umožňují vytvářet testy. Obě dělají stejnou věc. Jako první parametr berou popis testu a jako druhý funkci s testovacím kódem. V této funkci otestujeme nějaký kód a výsledek porovnáme s očekávaným výsledkem pomocí funkce expect.</p>
                </div>
                <pre class="code-box u-mb-6"><code>import {expect, it} from 'vitest';

it("should summarize all number values in an array", () => {
    const numbers = [1, 2, 3];
    const expectedResult = 6;

    // otestování kódu a získání výsledku
    const result = add(numbers);

    // porovnání výsledku s očekávaným výsledkem
    expect(result).toBe(expectedResult);
});</code></pre>
                <div class="intro-text u-center-text">
                    <p class="paragraph">Za funkci expect, do které předáváme hodnotu kterou chceme kontrolovat, můžeme řetězit spoustu metod, pomocí kterých můžeme předanou hodnotu zkontrolovat. Všechny můžete najít v <a href="https://vitest.dev/api/#expect" target="_blank" class="link">dokumentaci</a>.</p>
                </div>
            </div>
        </section>
        <section id="tobe-vs-toequal" class="section section--alt">
            <div class="section__content">
                <h2 class="heading-secondary u-center-text u-mb-6">toBe vs. toEqual</h2>
                <div class="intro-text u-mb-6">
                    <p class="paragraph paragraph--dark">Za funkci expect můžeme řetězit dvě podobné metody jménem toBe a toEqual. Rozdíl mezi nimi je ten, že toBe porovnává hodnoty přesně. Pokud chceme porovnávat dva objekty u kterých chceme zjistit jestli mají stejnou strukturu, tak je metoda toBe vyhodnotí jako rozdílné, protože jsou uloženy na jiném místě v paměti. Proto existuje metoda toEqual, která zjišťuje jestli se dvě hodnoty rovnají nebo mají stejnou strukturu.</p>
                </div>
                <div class="grid">
                    <div class="grid__col-1-of-2">
                        <pre class="code-box"><code>import {expect, it} from 'vitest';

it("should be equal", () => {
    const obj1 = {
        someValue: true,
        someOtherValue: 2
    };

    const obj2 = {
        someValue: true,
        someOtherValue: 2
    };

    // tento test selže (proměnná obj1 odkazuje na jiný objekt v paměti než obj2)
    expect(obj1).toBe(obj2);
});</code></pre>
                    </div>
                    <div class="grid__col-1-of-2">
                        <pre class="code-box"><code>import {expect, it} from 'vitest';

it("should be equal", () => {
    const obj1 = {
        someValue: true,
        someOtherValue: 2
    };

    const obj2 = {
        someValue: true,
        someOtherValue: 2
    };

    // tento test projde (obj1 má stejnou strukturu jako obj2)
    expect(obj1).toEqual(obj2);
});</code></pre>
                    </div>
                </div>
            </div>
        </section>
        <section id="seskupovani-testu" class="section">
            <div class="section__content">
                <h2 class="heading-secondary u-center-text u-mb-6">Seskupování testů</h2>
                <div class="intro-text u-mb-6">
                    <p class="paragraph">Vitest nám nabízí funkci describe, pomocí které můžeme v souboru seskupovat testy dohromady. To se může hodit, když například testujeme soubor obsahující různé funkce.</p>
                </div>
                <pre class="code-box"><code>import {describe, expect, it} from 'vitest';

// seskupení testů pro funkci add
describe("add()", () => {
    it("should do something...", () => {
        // ... nějaký test ...
    });
    it("should do something too...", () => {
        // ... nějaký test ...
    });
});

// seskupení testů pro funkci substract
describe("substract()", () => {
    it("should do something...", () => {
        // ... nějaký test ...
    });

    // describe funkce můžeme i vnořovat
    describe("something", () => {
        // ... nějaké další testy ...
    });
});</code></pre>
            </div>
        </section>
        <section id="testovani-chyb" class="section section--alt">
            <div class="section__content">
                <h2 class="heading-secondary u-center-text u-mb-6">Testování chyb</h2>
                <div class="intro-text u-mb-6">
                    <p class="paragraph paragraph--dark">U některých funkcí v našem kódu můžeme v určitých situacích očekávat, že vyhodí chybu. Vitest nám to umožňuje otestovat.</p>
                </div>
                <pre class="code-box"><code>
it("should throw an error", () => {
    const numbers = ["A", "B", "C"];

    // nejjednodušší cesta jak otestovat jestli nějaká funkce vrací error
    // je obalit její volání do jiné funkce a tu předat do expect funkce
    // - jinak bychom mohli využít i try a catch
    const resultFn = () => {
        add(numbers);
    }

    // očekáváme že funkce vyhodí chybu
    expect(resultFn).toThrow();
});</code></pre>
            </div>
        </section>
        <section id="testovani-asynchronniho-kodu" class="section">
            <div class="section__content">
                <h2 class="heading-secondary u-center-text u-mb-6">Testování asynchronního kódu</h2>
                <div class="intro-text u-mb-6">
                    <p class="paragraph">Při spouštění testů Vitest nečeká na to až se provedou callbacky a asynchronní kód. Proto může testovací funkce přijímat jako parametr funkci, kterou v testovací funkci zavoláme až budeme s testováním hotovi. Pokud ale testujeme kód, který používá promisy, tak je to o něco jednodušší.</p>
                </div>
                <div class="grid">
                    <div class="grid__col-1-of-2">
                        <h3 class="heading-tertiary u-center-text u-mb-4">Callbacky</h3>
                        <pre class="code-box"><code>import {expect, it} from 'vitest';

// testovací funkce jako parametr přijímá funkci, kterou zavoláme až budeme s testováním hotovi
it("should generate a token value", (done) => {
    const testUserEmail = 'test@test.com';

    generateToken(testUserEmail, (err, token) => {
        // metoda toBeDefined (a podobné metody) může vrátit error, ale tady se nacházíme v
        // callbacku, ne v it funkci, proto musíme její volání obalit do try catch bloku
        try {
            expect(token).toBeDefined();
            // pokud metoda toBeDefined nevyhodila žádný error, tak můžeme done funkci zavolat bez parametrů
            done();
        } catch(err) {
            // jako parametr předáváme do done funkce error, který metoda toBeDefined vyhodila
            done(err);
        }
    });
});</code></pre>
                    </div>
                    <div class="grid__col-1-of-2">
                        <h3 class="heading-tertiary u-center-text u-mb-4">Promisy</h3>
                        <pre class="code-box"><code>import {expect, it} from 'vitest';

it("should generate a token value", () => {
    const testUserEmail = 'test@test.com';

    // pokud testovaná funkce vrací promise, tak jej můžeme předat do expect funkce
    // - když předáváme do expect funkce promise, tak za ni můžeme řetězit resolves (pokud očekáváme že se promise splní)
    // nebo rejects (pokud očekáváme že se promise nesplní) a nakonec podmínku pro hodnotu s kterou se promise splní/nesplní
    // - funkce expect, která přijímá jako parametr promise, se musí v testovací funkci vrátit pomocí return
    return expect(generateToken(testUserEmail)).resolves.toBeDefined();
});

// pokud chceme používat async await, tak můžeme, testování je díky tomu ještě jednodušší
it("should generate a token value - v2", async () => { // testovací funkce je definována jako async (automaticky vrací promise)
    const testUserEmail = 'test@test.com';

    const token = await generateTokenPromise(testUserEmail);

    expect(token).toBeDefined();
});</code></pre>
                    </div>
                </div>
            </div>
        </section>
        <section id="hooks" class="section section--alt">
            <div class="section__content">
                <h2 class="heading-secondary u-center-text u-mb-6">Hooks</h2>
                <div class="intro-text u-mb-6">
                    <p class="paragraph paragraph--dark">Pokud používáme nějakou hodnotu ve více testech (v každém testu ji vytváříme), tak ji můžeme deklarovat mimo testy a v testech ji jen použít. Takto to ale můžeme udělat jen pro hodnoty, které se nemění. Jinak bychom museli před každém spuštění testu hodnotu resetovat. K tomuto účelu složí hooks. Můžeme s jejich pomocí spustit nějaký kód před/po každým/všemi testem.</p>
                </div>
                <pre class="code-box"><code>import {beforeEach, afterEach, beforeAll, afterAll, describe} from 'vitest';

beforeEach(() => {
    // kód, který se spustí před každým testem
});

afterEach(() => {
    // kód, který se spustí po každém testu
});

beforeAll(() => {
    // kód, který se spustí před všemi testy
});

afterAll(() => {
    // kód, který se spustí po provedení všech testů
});

// hooks můžeme také vnořovat do describe funkcí - budou se týkat jen testů, které describe funkce obsahuje
describe("add()", {
    beforeEach(() => { /* nějaký kód */ });
});
</code></pre>
            </div>
        </section>
        <section id="spioni" class="section">
            <div class="section__content">
                <h2 class="heading-secondary u-center-text u-mb-6">Špióni</h2>
                <div class="intro-text u-mb-6">
                    <p class="paragraph">Vitest nám umožňuje vytvořit si funkci, kterou můžeme použít jako obal nebo prázdnou náhradu pro jinou funkci. Máme s její pomocí možnost například zjistit, jestli byla funkce volána když ji předáme jako parametr testované funkci.</p>
                </div>
                <pre class="code-box u-mb-6"><code>import {it, expect, vi} from 'vitest';

it("should call passed function", () => {
    // vytvoření špionážní funkce
    const callback = vi.fn();

    // předání špionážní funkce jako parametr testované funkci
    generateData(callback);

    // očekáváme že se funkce callback ve funkci generateData zavolala
    expect(callback).toBeCalled();

    // dále můžeme po předání špionážní funkce do expect funkce řetězit metody:
    // toBeCalledTimes, toBeCalledWith, atd... (více v dokumentaci)
});</code></pre>
                <a href="https://vitest.dev/api/#vi-fn" target="_blank" class="link-with-icons">
                    <div class="link-with-icons__icon">
                        <svg>
                            <use xlink:href="./assets/img/icon-sprite.svg#icon-arrow-right2"></use>
                        </svg>
                    </div>
                    <span>více v dokumentaci</span>
                    <div class="link-with-icons__icon">
                        <svg>
                            <use xlink:href="./assets/img/icon-sprite.svg#icon-arrow-left2"></use>
                        </svg>
                    </div>
                </a>
            </div>
        </section>
        <section id="mocking" class="section section--alt">
            <div class="section__content">
                <h2 class="heading-secondary u-center-text u-mb-6">Mocking</h2>
                <div class="intro-text u-mb-6">
                    <p class="paragraph paragraph--dark">Vitest nám umožňuje nahradit části API jiným kódem. Při testování například nechceme, aby funkce která něco ukládá na disk opravdu něco na disk ukládala. Chceme to jen otestovat. Proto můžeme třeba změnit funkcionalitu funkcí, které testovaná funkce používá k zápisu dat na disk.</p>
                </div>
                    <pre class="code-box u-mb-6"><code>import {it, expect, vi} from 'vitest';
import {promises as fs} from 'fs';

// všechny funkce v modulu fs se změní v prázdné funkce
vi.mock(fs);

it('should execute the writeFile method', () => {
    const testData = 'Test';
    const testFilename = 'test.txt';

    // otestování funkce writeData
    writeData(testData, testFilename);

    // očekáváme že se funkce writeFile ve funkci writeData zavolá
    expect(fs.writeFile).toBeCalled();
});</code></pre>
                <div class="intro-text u-mb-6">
                    <p class="paragraph paragraph--dark">Pokud chceme pro nějakou funkci v modulu nastavit jinou než prázdnou funkci, tak to můžeme udělat následující způsobem:</p>
                </div>
                <pre class="code-box u-mb-6"><code>vi.mock(path, () => {
    return {
        default: {
            // náhrada pro funkci join v modulu path
            join: (...args) => {
                return args[args.length - 1];
            }
        }
    }
});</code></pre>
                <div class="intro-text u-mb-6">
                    <p class="paragraph paragraph--dark">Pokud chceme mockovat stejný module ve více souborech, tak kód pro jeho mockování můžeme přesunout do samostatného souboru. Vitest nám umožňuje vytvořit si složku __mocks__, kde můžeme vytvářet soubory pojmenované jako názvy modulů (třeba fs.js). V těchto souborech můžeme exportovat mocknutou funkcionalitu, kterou chceme používat když v jiných souborech zavoláme vi.mock.</p>
                </div>
                <pre class="code-box u-mb-6"><code>// __mocks__/fs.js

import { vi } from 'vitest';

// mocknutí části modulu fs jménem promises
export const promises = {
    // náhrada pro funkci writeFile
    writeFile: vi.fn((path, data) => {
        return new Promise((resolve, reject) => {
            resolve();
        });
    })
}</code></pre>
                <div class="intro-text u-mb-6">
                    <p class="paragraph paragraph--dark">Pokud chceme mocknout nějakou globální funkci, tak nám Vitest poskytuje kromě metody mock také metodu stubGlobal, kterou k tomu můžeme využít.</p>
                </div>
                <pre class="code-box"><code>const testFetch = vi.fn();
// mocknutí globální funkce jménem fetch
vi.stubGlobal("fetch", testFetch);</code></pre>
            </div>
        </section>
        <section id="dom-testovani" class="section">
            <div class="section__content">
                <h2 class="heading-secondary u-center-text u-mb-6">DOM testování</h2>
                <div class="intro-text u-mb-6">
                    <p class="paragraph">Pokud chceme testovat DOM, tak nejprve musíme změnit prostředí, ve kterém se náš testovací kód spouští. Máme na výběr z těchto tří možností:</p>
                </div>
                <div class="grid u-center-text u-mb-6">
                    <div class="grid__col-1-of-3">
                        <h3 class="heading-tertiary heading-tertiary--lowercase u-mb-4">node</h3>
                        <p class="paragraph">Tato možnost je nastavena jako defaultní. V tomto prostředí jsou k dispozici NodeJS API a moduly.</p>
                    </div>
                    <div class="grid__col-1-of-3">
                        <h3 class="heading-tertiary heading-tertiary--lowercase u-mb-4">jsdom</h3>
                        <p class="paragraph">Prostředí pro testování frontend kódu. K dispozici také třeba v testovacím frameworku jménem Jest.</p>
                    </div>
                    <div class="grid__col-1-of-3">
                        <h3 class="heading-tertiary heading-tertiary--lowercase u-mb-4">happy-dom</h3>
                        <p class="paragraph">Další prostředí pro testování frontend kódu.</p>
                    </div>
                </div>
                <div class="intro-text u-mb-2">
                    <p class="paragraph">Prostředí ve kterém se naše testy spustí můžeme nastavit pomocí možnosti --environment:</p>
                </div>
                <p class="big-text u-center-text u-highlight-text u-mb-6">vitest --environment happy-dom</p>
                <h3 class="heading-tertiary u-center-text u-mb-4">Načtení stránky pro testování</h3>
                <div class="intro-text u-mb-6">
                    <p class="paragraph">Předtím než začneme s testováním, tak musíme načíst stránku, kterou chceme testovat. To můžeme udělat následujícím způsobem (používáme happy-dom):</p>
                </div>
                <pre class="code-box u-mb-6"><code>import fs from 'fs';
import path from 'path';
import { Window } from 'happy-dom';


// získání cesty k HTML souboru
const htmlDocPath = path.join(process.cwd(), 'index.html');
// přečtení HTML souboru a uložení jeho obsahu do proměnné
const htmlDocumentContent = fs.readFileSync(htmlDocPath).toString();

// vytvoření nového window objektu
const window = new Window();
// získání documentu window objektu
const document = window.document;
// zapsání obsahu HTML souboru do documentu
document.write(htmlDocumentContent);

// změnění documentu na document virtuálního DOMu
vi.stubGlobal('document', document);</code></pre>
                <h3 class="heading-tertiary u-center-text u-mb-4">Příklad DOM testování</h3>
                <div class="intro-text u-mb-6">
                    <p class="paragraph">Následující ukázka ukazuje, jakým způsobem můžeme DOM testovat.</p>
                </div>
                <pre class="code-box u-mb-6"><code> /* ... kód z minulé ukázky a importy ... */

// při DOM testování bychom měli virtual DOM před každým testem resetovat
beforeEach(() => {
    // smazání obsahu documentu
    document.body.innerHTML = '';
    // zapsání obsahu HTML souboru do documentu
    document.write(htmlDocumentContent);
    // stubGlobal volat nemusíme, protože document je objekt a ten se předává adresou
});

it('should add new element to the id="todo-list" element', () => {
    // spuštění testované funkce
    addItem("create website");

    // získání elementu s ID todo-list
    const todoList = document.getElementById("todo-list");
    // získání prvního elementu z elementu s ID todo-list
    const liElement = todoList.firstElementChild;

    // očekáváme že se do elementu s ID todo-list přidal nový element
    expect(liElement).not.toBeNull();
});</code></pre>
                <div class="intro-text">
                    <p class="paragraph">Pro testování DOMu nám JSDOM nebo Happy-DOM nemusí stačit. Proto existují různé knihovny pro DOM testování. Jednou z nich je třeba <a href="https://testing-library.com/" class="link">Testing Library</a>, pomocí které můžeme jednoduše testovat i populární frontend frameworky jako je React.</p>
                </div>
            </div>
        </section>
        <footer class="footer">
            <p class="paragraph paragraph--white">Tento tahák vytvořil <a href="https://jirkasa.github.io/" target="_blank" class="link">Jiří Satora</a></p>
        </footer>
    </div>
</body>
</html>